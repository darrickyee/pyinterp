#!/usr/bin/env python3.8
# @generated by pegen from <string>

import ast
from typing import Optional, Any

from pegen.parser import memoize, memoize_left_rec, logger, Parser

from .parseinit import (
    flatten,
    get_str,
    Cond,
    PyExec,
    PyExpr,
    Section,
    Line,
    Choice,
    Goto
)

class GeneratedParser(Parser):

    @memoize
    def start(self) -> Optional[Any]:
        # start: statements $
        mark = self.mark()
        cut = False
        if (
            (statements := self.statements())
            and
            (endmarker := self.expect('ENDMARKER'))
        ):
            return Section ( None , statements )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def statements(self) -> Optional[Any]:
        # statements: statement*
        # nullable=True
        mark = self.mark()
        cut = False
        if (
            (a := self._loop0_1(),)
        ):
            return flatten ( a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def statement(self) -> Optional[Any]:
        # statement: py_expr lang_stmt | py_expr NEWLINE block | lang_stmt
        mark = self.mark()
        cut = False
        if (
            (c := self.py_expr())
            and
            (s := self.lang_stmt())
        ):
            return Cond ( c , body = s )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (c := self.py_expr())
            and
            (newline := self.expect('NEWLINE'))
            and
            (s := self.block())
        ):
            return Cond ( c , body = s )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (lang_stmt := self.lang_stmt())
        ):
            return lang_stmt
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def lang_stmt(self) -> Optional[Any]:
        # lang_stmt: section_stmt | line_stmt | code_stmt | choice_stmt | goto_stmt
        mark = self.mark()
        cut = False
        if (
            (section_stmt := self.section_stmt())
        ):
            return [section_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (line_stmt := self.line_stmt())
        ):
            return [line_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (code_stmt := self.code_stmt())
        ):
            return [code_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (choice_stmt := self.choice_stmt())
        ):
            return [choice_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (goto_stmt := self.goto_stmt())
        ):
            return [goto_stmt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def section_stmt(self) -> Optional[Any]:
        # section_stmt: ('section' | '==' '=') section_label NEWLINE block?
        mark = self.mark()
        cut = False
        if (
            (_tmp_2 := self._tmp_2())
            and
            (section_label := self.section_label())
            and
            (newline := self.expect('NEWLINE'))
            and
            (body := self.block(),)
        ):
            return Section ( section_label , body = body )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def section_label(self) -> Optional[Any]:
        # section_label: '.'.NAME+
        mark = self.mark()
        cut = False
        if (
            (a := self._gather_3())
        ):
            return [ n . string for n in a ]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def line_stmt(self) -> Optional[Any]:
        # line_stmt: ('line' | '-') STRING NEWLINE block?
        mark = self.mark()
        cut = False
        if (
            (_tmp_5 := self._tmp_5())
            and
            (a := self.string())
            and
            (newline := self.expect('NEWLINE'))
            and
            (body := self.block(),)
        ):
            return Line ( get_str ( a ) , body = body )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def code_stmt(self) -> Optional[Any]:
        # code_stmt: ('code' | '$') py_token_str* NEWLINE | ('code' | '$') NEWLINE INDENT py_block DEDENT
        mark = self.mark()
        cut = False
        if (
            (_tmp_6 := self._tmp_6())
            and
            (a := self._loop0_7(),)
            and
            (newline := self.expect('NEWLINE'))
        ):
            return PyExec ( ' ' . join ( a ) )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (_tmp_8 := self._tmp_8())
            and
            (newline := self.expect('NEWLINE'))
            and
            (i := self.expect('INDENT'))
            and
            (py_block := self.py_block())
            and
            (dedent := self.expect('DEDENT'))
        ):
            return PyExec ( '' . join ( line [ len ( i . string ) : ] for line in py_block ) )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def choice_stmt(self) -> Optional[Any]:
        # choice_stmt: ('choice' | '*') STRING NEWLINE block?
        mark = self.mark()
        cut = False
        if (
            (_tmp_9 := self._tmp_9())
            and
            (a := self.string())
            and
            (newline := self.expect('NEWLINE'))
            and
            (body := self.block(),)
        ):
            return Choice ( a . string , body = body )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def goto_stmt(self) -> Optional[Any]:
        # goto_stmt: ('goto' | '->') section_label NEWLINE | ('goto' | '->') py_expr NEWLINE
        mark = self.mark()
        cut = False
        if (
            (_tmp_10 := self._tmp_10())
            and
            (section_label := self.section_label())
            and
            (newline := self.expect('NEWLINE'))
        ):
            return Goto ( section_label )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (_tmp_11 := self._tmp_11())
            and
            (py_expr := self.py_expr())
            and
            (newline := self.expect('NEWLINE'))
        ):
            return Goto ( py_expr )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def block(self) -> Optional[list]:
        # block: INDENT statements DEDENT
        mark = self.mark()
        cut = False
        if (
            (indent := self.expect('INDENT'))
            and
            (a := self.statements())
            and
            (dedent := self.expect('DEDENT'))
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def py_block(self) -> Optional[list]:
        # py_block: py_line py_block | py_line
        mark = self.mark()
        cut = False
        if (
            (py_line := self.py_line())
            and
            (py_block := self.py_block())
        ):
            return py_line + py_block
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (py_line := self.py_line())
        ):
            return py_line
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def py_line(self) -> Optional[str]:
        # py_line: INDENT py_block DEDENT | (NAME | NUMBER | STRING | OP) ((NAME | NUMBER | STRING | OP))* NEWLINE
        mark = self.mark()
        cut = False
        if (
            (indent := self.expect('INDENT'))
            and
            (py_block := self.py_block())
            and
            (dedent := self.expect('DEDENT'))
        ):
            return py_block
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._tmp_12())
            and
            (_loop0_13 := self._loop0_13(),)
            and
            (newline := self.expect('NEWLINE'))
        ):
            return [ a [ 0 ] . line ]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def py_expr(self) -> Optional[str]:
        # py_expr: '{' py_terms '}'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('{'))
            and
            (py_terms := self.py_terms())
            and
            (literal_1 := self.expect('}'))
        ):
            return PyExpr ( py_terms )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def py_terms(self) -> Optional[str]:
        # py_terms: py_term py_terms | py_term
        mark = self.mark()
        cut = False
        if (
            (py_term := self.py_term())
            and
            (py_terms := self.py_terms())
        ):
            return py_term + ' ' + py_terms
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (py_term := self.py_term())
        ):
            return py_term
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def py_term(self) -> Optional[str]:
        # py_term: '{' ~ py_terms? '}' | py_value_str | !'}' OP
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('{'))
            and
            (cut := True)
            and
            (a := self.py_terms(),)
            and
            (literal_1 := self.expect('}'))
        ):
            return "{" + ( a or "" ) + "}"
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (py_value_str := self.py_value_str())
        ):
            return py_value_str
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.negative_lookahead(self.expect, '}')
            and
            (op := self.op())
        ):
            return op . string
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def py_token_str(self) -> Optional[Any]:
        # py_token_str: py_value_str | py_op_str
        mark = self.mark()
        cut = False
        if (
            (py_value_str := self.py_value_str())
        ):
            return [py_value_str]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (py_op_str := self.py_op_str())
        ):
            return [py_op_str]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def py_value_str(self) -> Optional[str]:
        # py_value_str: NAME | NUMBER | STRING
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
        ):
            return name . string
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (number := self.number())
        ):
            return number . string
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (string := self.string())
        ):
            return string . string
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def py_op_str(self) -> Optional[str]:
        # py_op_str: OP
        mark = self.mark()
        cut = False
        if (
            (op := self.op())
        ):
            return op . string
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_1(self) -> Optional[Any]:
        # _loop0_1: statement
        mark = self.mark()
        children = []
        cut = False
        while (
            (statement := self.statement())
        ):
            children.append([statement])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_2(self) -> Optional[Any]:
        # _tmp_2: 'section' | '==' '='
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('section'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('=='))
            and
            (literal_1 := self.expect('='))
        ):
            return [literal, literal_1]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_4(self) -> Optional[Any]:
        # _loop0_4: '.' NAME
        mark = self.mark()
        children = []
        cut = False
        while (
            (literal := self.expect('.'))
            and
            (elem := self.name())
        ):
            children.append(elem)
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _gather_3(self) -> Optional[Any]:
        # _gather_3: NAME _loop0_4
        mark = self.mark()
        cut = False
        if (
            (elem := self.name())
            is not None
            and
            (seq := self._loop0_4())
            is not None
        ):
            return [elem] + seq
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_5(self) -> Optional[Any]:
        # _tmp_5: 'line' | '-'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('line'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('-'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_6(self) -> Optional[Any]:
        # _tmp_6: 'code' | '$'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('code'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('$'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_7(self) -> Optional[Any]:
        # _loop0_7: py_token_str
        mark = self.mark()
        children = []
        cut = False
        while (
            (py_token_str := self.py_token_str())
        ):
            children.append([py_token_str])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_8(self) -> Optional[Any]:
        # _tmp_8: 'code' | '$'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('code'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('$'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_9(self) -> Optional[Any]:
        # _tmp_9: 'choice' | '*'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('choice'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('*'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_10(self) -> Optional[Any]:
        # _tmp_10: 'goto' | '->'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('goto'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('->'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_11(self) -> Optional[Any]:
        # _tmp_11: 'goto' | '->'
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('goto'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('->'))
        ):
            return [literal]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _tmp_12(self) -> Optional[Any]:
        # _tmp_12: NAME | NUMBER | STRING | OP
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
        ):
            return [name]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (number := self.number())
        ):
            return [number]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (string := self.string())
        ):
            return [string]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (op := self.op())
        ):
            return [op]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def _loop0_13(self) -> Optional[Any]:
        # _loop0_13: (NAME | NUMBER | STRING | OP)
        mark = self.mark()
        children = []
        cut = False
        while (
            (_tmp_14 := self._tmp_14())
        ):
            children.append([_tmp_14])
            mark = self.mark()
        self.reset(mark)
        if cut: return None
        return children

    @memoize
    def _tmp_14(self) -> Optional[Any]:
        # _tmp_14: NAME | NUMBER | STRING | OP
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
        ):
            return [name]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (number := self.number())
        ):
            return [number]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (string := self.string())
        ):
            return [string]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (op := self.op())
        ):
            return [op]
        self.reset(mark)
        if cut: return None
        return None


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
